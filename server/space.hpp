/* By Tyler Clarke
    This work is protected by the GNU GPLv3 license, which is attached in the root directory of the project.
    TLDR; don't make closed-source stuff with my code, don't lie about writing it yourself, don't license it anything other than GPLv3.
    you can sell derivative works if you want (as long as the source code is provided), but that would be dumb.
    
    This is MSAG's Space subsystem. Spaces contain physical pieces - player pieces, the ground, etc. They're generated by maps and managed by rooms.

    If you're lookin' to contribute, just ctrl+F for the word "TODO". There's a *lot* of TODO. Seriously. If your only contribution to the file is
    to add your name at the top, I'm not going to accept it. I'm looking at you, 1000D ;)
*/
#pragma once
#include <mutex>
struct Room; // forward-dec. BIG, BIG TODO: Make this a proper Makefile project with separate header files and definitions! Will save us a LOT of pain!


struct Space {
    // Spaces are not organized into logical tiles, but some things inside them (most ground types, for instance) prefer to fit into tiles, and most of the player
    // interaction will look like it's organized into tiles of different sizes. Ground tiles are 100x100 and most other things are 50x50 or 1x50 or 50x1. Nice round
    // numbers. Things don't need to be aligned to grids, but clients should align stuff to grids anyways because the grid aesthetic is cool.
    // Ground is the first optimization level and thus most efficient thing in the game. It's handled in layers. The first layer should be the
    // size of the entire Space. Other layers atop could be things like sand, rocks, etc. Ground can always be walked on, use obstructions for things like boulders.
    // Ground cannot ever be destroyed; if you strip off the stuff on top of it, you'll always get to the same ol' ground.
    // Obstructions are the second optimization level. They experience collisions, but don't have update logic of their own and don't ever move; this is things
    // like fences and boulders. Obstructions can be destroyed, optionally. Obstructions can have handler functions for when something else hits them.
    // The third optimization level is *everything else* - these are what get their own expensive update loops and have collision logic with everything.
    // Players fall into this category.
    uint32_t spaceID; // the id of this space inside its room.
    float width; // should never be too excessive.
    float height;

    Room* room;
    std::mutex mutex; // For the Space-manager threads to lock spaces and then run them.
    
    uint64_t updateTime; // in milliseconds. if current time is ever more than or equal to update time, update and increment updateTime by 1000/SPEED.

    Space(uint32_t id) {
        spaceID = id;
    }

    void update() {
        printf("%d got updated!\n", spaceID);
    }
};