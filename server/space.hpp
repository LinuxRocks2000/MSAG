/* By Tyler Clarke
    This work is protected by the GNU GPLv3 license, which is attached in the root directory of the project.
    TLDR; don't make closed-source stuff with my code, don't lie about writing it yourself, don't license it anything other than GPLv3.
    you can sell derivative works if you want (as long as the source code is provided), but that would be dumb.
    
    This is MSAG's Space subsystem. Spaces contain physical pieces - player pieces, the ground, etc. They're generated by maps and managed by rooms.

    If you're lookin' to contribute, just ctrl+F for the word "TODO". There's a *lot* of TODO. Seriously. If your only contribution to the file is
    to add your name at the top, I'm not going to accept it. I'm looking at you, 1000D ;)
*/
// TODO: separate into a header and a definition (because eventually we're going to need to do makefile)
#pragma once

#define GROUND_TYPE_SOIL  0 // The simplest ground type. You can walk on it fine, and garden on it find. It has no special behaviors. Holds water.
#define GROUND_TYPE_SAND  1 // Hard to walk on, low gardening potential, perfectly absorbs water. Very annoying.
#define GROUND_TYPE_ROCKS 2 // Easy to walk on, impossible to garden on for most plants.
// Every ground type can have different parameters; the ones listed above are just general guidelines. The reason for the ground type system is to
// allow special behaviors - like, you can't plant *most* things on sand, but sand will accept cactii (which can't grow elsewhere) and palm trees and such.
// Add more types at convenience.

#include <stdio.h>
#include "util/rect.hpp"
#include <mutex>
#include <vector>
#include <player.hpp>
struct Room; // forward-dec. BIG, BIG TODO: Make this a proper Makefile project with separate header files and definitions! Will save us a LOT of pain!


struct Ground { // all ground types are stored in this struct. It's slightly more efficient than inheritance, and it's simple enough not to matter.
    Rect shape;

    float moveHindrance; // How much it hinders motion. 0 = no hindrance, 1 = impossible to move while on it.
    float gardenPotential; // How easy it is to garden on this. 0 = perfect soil, 1 = not gardenable.

    int type; // see above

    uint32_t spaceID; // ID of this object within the space

    // Everything can always move over ground. It doesn't obstruct.
    
    static Ground makeBasicEarth(Rect r) { // The simplest soil type. you always have to configure the x, y, w, h properties yourself!
        return {
            .shape = r,
            .moveHindrance = 0.2, // a little higher than Rock.
            .gardenPotential = 0.3, // it's pretty good for gardening too
            .type = GROUND_TYPE_SOIL
        };
    }
};


struct Space {
    // Spaces are not organized into logical tiles, but some things inside them (most ground types, for instance) prefer to fit into tiles, and most of the player
    // interaction will look like it's organized into tiles of different sizes. Ground tiles are 100x100 and most other things are 50x50 or 1x50 or 50x1. Nice round
    // numbers. Things don't need to be aligned to grids, but clients should align stuff to grids anyways because the grid aesthetic is cool.
    // Ground is the first optimization level and thus most efficient thing in the game. It's handled in layers. The first layer should be the
    // size of the entire Space. Other layers atop could be things like sand, rocks, etc. Ground can always be walked on, use obstructions for things like boulders.
    // Ground cannot ever be destroyed; if you strip off the stuff on top of it, you'll always get to the same ol' ground.
    // Obstructions are the second optimization level. They experience collisions, but don't have update logic of their own and don't ever move; this is things
    // like fences and boulders. Obstructions can be destroyed, optionally. Obstructions can have handler functions for when something else hits them.
    // The third optimization level is *everything else* - these are what get their own expensive update loops and have collision logic with everything.
    // Players fall into this category.
    uint32_t spaceID; // the id of this space inside its room.
    float width; // should never be too excessive.
    float height;
    float defaultX = 100.0; // default spawn position. This will usually be over a White Block, a type of obstruction specifically meant to aid spawning players.
    float defaultY = 100.0;
    uint16_t playerCount = 0; // the number of ACTIVE players in this space. A player is active if these conditions are satisfied:
    /* 
        1. it is currently connected
        2. it is alive (ghosts will witness the room-freeze, yes)
    */
    // When playerCount is 0, the space will no longer receive updates.

    Room* room;
    std::mutex mutex; // For the Space-manager threads to lock spaces and then run them.
    
    uint64_t updateTime; // in milliseconds. if current time is ever more than or equal to update time, update and increment updateTime by 1000/SPEED.

    std::vector<Ground> groundLayer;

    // Since Players require a number of special routines and have special requirements and optimizations (like Ground), they have a separate vector.

    std::vector<Player> players;

    uint32_t topSpaceID = 0; // ids of things actually inside this space
    
    uint32_t allocateID() {
        topSpaceID ++;
        return topSpaceID - 1;
    }

    Space(float w, float h) {
        spaceID = 0;
        width = w;
        height = h;
    }

    void addGround(Ground g) {
        groundLayer.push_back(g);
    }

    void addPlayer(Player p) {
        p.spaceID = allocateID();
        players.push_back(p);
    }

    void update() {
        //printf("%d got updated!\n", spaceID);
    }
};